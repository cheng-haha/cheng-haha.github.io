# 南师大专业课面试

## 1. C语言

1. **请你谈谈对指针的理解**
   * 指针就是地址。每个存储单元都有其对应的地址，所以指针就是内存单元的编号。并且一个变量的地址，不仅有地址信息，还有其类型信息。总之，对于指针有如下三种信息：

     1. 指针就是表示内存单元的纯地址，这是地址信息。

     2. 指针所代表的它本身的类型，比如说a是int类型，那么a的指针它本身的类型就是指向int类型

     3. 指针所代表的存储单元的基类型。比如我int a，a的地址的基类型就是int，或者说a的指针的基类型就是int。

        指针本身的类型和它的基类型就是指针的类型信息。

   * 指针与指针变量是有区别的，指针就是地址，指针变量存储的是指针，或者说指针变量存储的就是地址。两者是包含关系。而且，一个指针变量必须接收相同类型的指针。比如说我int * p ，那么这个p只能接收指向int类型的指针。
2. **请你谈谈对c语言如何打开文件**
   * 一般来说，打开文件可以模板化，file * fp ， fp = fopen("文件"，模式选择)，fclose(fp)
   * 首先，利用file * fp 用来接收fopen函数打开文件后返回的文件结构体指针。其次，对文件的各种操作都是写进文件缓冲区的，如果想对文件进行写操作，就必须要利用fclose函数，才能将文件缓冲区的文件送入文件。也就是说fopen和fclose一般来说都是成对出现。

## 2.自控

1. **请你谈谈对pid的理解**

   pid是比例积分微分控制。pid控制我是从传递函数来理解的。pid相当于给原系统增加了一个原点上的极点和两个开环零点。第一，极点将系统提高了一个型别，减少甚至消除了稳态误差，系统更准。第二，一个零点平衡掉极点破坏的稳定性。第三，另一个开环零点增加系统的动态性能，使系统更快。pid满足了自控要求的稳准快三个要求指标，经过对kp，ki，kd的调参，可以得到良好的控制效果。

2. **AD，DA是如何进行转换的？**

   请参考自控离散系统

## 3.数据结构

1. **基础概念**
   1. 时间复杂度？

      时间复杂度是语句频度之和的数量级表示。时间复杂度T(n)是问题规模n的函数，但我们一般用大O表示法来表示。也就是对于时间复杂度的函数取n的阶数最大的作为时间复杂度的近似值。比如说一个T(n)为。。。。。，举个例子

   2. 空间复杂度？

      空间复杂度定义为算法所耗费的存储空间，也可以用大O表示法来说明。

2. **线性表**

   * 定义：线性表是相同数据组成的有限序列。线性表满足以下几个条件：
     1. 线性表只有唯一的表头元素以及唯一的表尾元素
     2. 除了表头结点外的所有结点都有它的直接前驱
     3. 除了表尾结点外的所有结点都有它的直接后继
   * 具体操作：创建销毁，增删改查

   1. 顺序表

      一片连续的线性表就叫做顺序表，把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中。

      * 随机存取
      * 存储密度高
      * 拓展容量不方便
      * 大片连续空间分配不方便
      * 插入删除耗费时间长

      1. 数组的静态分配和动态分配

         静态分配是在栈内分配，系统自动回收，但不能拓展容量，初始化后就不能对其增加容量。

         动态分配是在堆区分配，可以拓展容量，系统不进行回收，得用free函数进行释放。

         

   2. 链表

      存储空间分散，通过结点依次连接的线性表就是链表

      * 拓展容量方便
      * 分配空间方便
      * 不能随机存取
      * 存储密度低

      1. 头插法的逆置操作很重要

      总结：顺序表和链表在逻辑结构上都是线性结构，都属于线性表。但是二者在存储结构上是不同的，顺序表采用顺序存储，系统分配一片连续的内存，逻辑结构上相邻，存储结构也是相邻的，可以随机存取，存储密度高，但扩容不方便，查找删除的时间效率也较低；链表采用链式存储，使用的离散的空间，分布在内存区的各个角落，存储密度低，查找删除方便，扩容方便。

3. **栈和队列**
   1. 什么是栈

      栈是一种操作受限的线性表，是一种被规定只能在一端插入删除的线性表，也就是先进后出原则。

      * 可顺序存储

      * 可链式存储

        如果以头插法去模拟出栈入栈的话，会发现头插法跟栈的后进先出的特性完全一置。

   2. 什么是队列

      队列是一种只允许在一端插入，在另一端删除的线性表，也就是先进先出原则。

      * 顺序存储

        1. 实现方式：用静态数组的方式存放数据元素，设置队头队尾指针。

        2. 循环队列：循环队列就是队列呈现出一个环状，这里我们需要用到模运算，假设队列为Q在队列这个结构体我定义了数组元素和队头指针front，队尾指针rear，那么我们最关键的两个操作就是入队时对Q.rear进行模运算处理，在出队时对Q.front进行模运算处理，这两个处理下就会让数组呈现一种环状结构。

        3. 如何判空，判满？

           判空操作就是Q.rear是否等于Q.front,是就是空。判满操作可以用到两种方法，一个是牺牲一个存储单元，使用(Q.rear+1)%MAXSIZE==Q.front,另一种就是采用辅助变量的方式，在定义队列结构体时定义一个int类型的tag变量，因为只有在出队时队列才会空，只有入队时队列才会满，那么可以在每次执行出队操作时将tag置0，在每次入队操作时将tag置1。如果按照这个思路，那么判空操作就可以是Q.rear==Q.front并上tag==0，在判满操作中观察Q.rear==Q.front并上tag==1.

        4. 求队长？

           (Q.rear+MAXSIZE-Q.front)%MAXSIZE

           记住模运算是将无限的整数域映射到有限的范围内。

   3. 双端队列

      * 定义：允许在两端插入和删除的线性表

   4. 栈和队列的应用

      1. 栈的应用
         1. 栈的括号匹配问题
            * 依次扫描所有字符，遇到左括号入栈，遇到右括号就出栈检查是否匹配
            * 匹配失败情况：
              1. 左括号单身
              2. 不匹配
              3. 右括号单身
         2. 表达式求值问题
            1. 三种表达式：

               * 前缀表达式：[ 运算符 左操作数 右操作数 ]
               * 中缀表达式：[  左操作数 运算符 右操作数 ]
               * 后缀表达式：[  左操作数  右操作数 运算符 ]

            2. 中缀表达式的计算

               1. 初始化两个栈，一个是操作数栈，一个是运算符栈。操作数栈对原来公式进行后缀转换，运算符栈对原来公式转换的后缀表达式进行运算。

            3. 栈在函数调用时的应用

               最后被调用的函数最先运行结束，这就跟栈后进先出的特点一样。在递归调用也是需要用到函数调用栈。

      2. 队列的应用

         树：层次遍历

         图：广度优先遍历BFS

         打印机数据缓冲区就是队列的一个思想。先来的任务先执行，后来的任务就在后面排队.

4. **串**

   * 可顺序存储

     ```C
     #define MAXSIZE  10 
     typedef struct SSTring{
         char ch[MAXSIZE] ;
         int length;
     }SSTring ;
     ```

   * 可链式存储

     ~~~C
     typedef struct SString{
         char data ;
         struct SSting * next ;
     }SSting , *LinkString ;
     ~~~

     

   最好采用顺序存储

   1. 定义:零个或多个字符组成的有限序列.

   2. 简单模式匹配算法( 又叫朴素模式匹配算法 )

      1. 定义：在主串中找到与模式串匹配的子串，并返回位置

      2. 思想：将子串和模式串一一对比，如果匹配成功返回当前位置，如果匹配失败，将检索位置加一，再依次将子串与模式串对比，重复以上步骤。

      3. 算法：首先设立三个指针，两个作为模式串和子串的扫描指针，一个作为主串的检索指针。

         ​            其次由检索指针开始，让主串对应的指针i和模式串扫描指针j同时对比当前元素，如果在模式

         ​            串长度内对比完成，就说明匹配成功，返回当前检索指针对应的位置；如果出现扫描指针不匹

         ​	    配的情况，将检索指针加一，然后让子串扫描指针回退到检索指针的位置，让模式串扫描指针

         ​            回退到原点；之后还是按照一个字符一个字符对比的办法进行对比，失败就回退指针，将检索

         ​	    指针加一，成功就返回当前检索指针位置。

   3. KMP算法

      1. 为什么有KMP算法？

         因为要解决朴素模式匹配算法的主串回溯问题。假设模式串有四个字符，可能模式串前三个字符与子串前三个字符相等，但是第四个字符是不相等的，如果还是采用简单匹配算法，子串的扫描指针会回溯到第二个字符的位置，还是会一一对比，但你其实已经知道后面会有一个字符与模式串不匹配，这样会导致多余的对比，增大时间复杂度。

      2. KMP算法就是让主串的扫描指针不回溯，然后对模式串去设置一个数组，这个数组记录了模式串应该回溯的位置，当匹配不成功时，让模式串回溯，让主串一直向后走。

      3. NEXT数组：存储的是模式串的前缀和后缀最大匹配长度。 

5. **树**

   **请熟练手写先序，中序，后序，层次遍历，中序线索化的代码，**

   1. 树的定义，二叉树？平衡二叉树？二叉排序树？完全二叉树？

      1. 二叉树是一种层次划分的数据结构。由根结点和左子树或者右子树组成，可以没有左子树，也可以没有右子树，而且当连祖先节点都没有的时候，也是二叉树，叫空二叉树。
      2. 满二叉树：每一层的结点数量为2的n次方，n从0开始。
      3. 完全二叉树：完全二叉树就是在满二叉树的基础上允许没有最后几个连续的叶子结点。
      4. 二叉排序树：左子树上多有结点关键字都小于根节点的关键字，右子树上所有关键字都小于根节点的关键字。
      5. 平衡二叉树：树上任一结点的左子树和右子树的深度子差不超过1。

   2. 存储结构：

      1. 顺序存储
      2. 链式存储，推荐链式

   3. 二叉树的遍历
      1. 先序遍历？
      2. 中序遍历？
      3. 后序遍历？
      4. 层序遍历？

   4. 树的线索化？

      1. 存储结构：

         ~~~C
         typedef struct BiTree{
             Elemtype data ;
             struct BiTree * lchild , * rchild ;
             int ltag . rtag ;
         }BiTree , * LinkTree ;
         ~~~

         * 在普通的二叉树的基础上，设置两个标志位lchild , rchild 
         * ltag == 1时， 就认为该左指针域已经指向了前驱结点； 如果为0 ，就认为是没有对其线索化，指向的就是左孩子结点
         * rtag == 1时 ， 就认为该右指针域已经指向了后继结点；如果为0 ，就认为是没有对其线索化，指向的就是右孩子结点

      2. 三种线索化二叉树

         * 先序线索化二叉树：指针域指向的是先序前驱，先序后继
         * 中序线索化二叉树：指针域指向的是中序前驱，中序后继
         * 后序线索化二叉树：指针域指向的是后序前驱，后序后继

         1. 中序线索化的方法：由中序遍历对数进行中序线索化。设置指针p作为访问指针，设置指针pre为刚刚被访问过的指针。在中序遍历的过程中，当p指向的结点左指针域为空时，就将左指针指向pre；当pre结点的右指针域指向为空时，就将当前pre结点的右指针指向结点p。

   5. 哈夫曼树？

      1. 带权路径长度最小的二叉树就是哈夫曼树。

6. **图**

   **请熟练手写BFS，DFS，BFS生成最小生成树，拓扑排序代码**

   1. 图的一些零碎概念，比如说联通图？有向图？无向图？极大联通子图？

   2. 图的存储结构？

      1. 领接矩阵
      2. 领接表法
      3. 十字链表法
      4. 领接多重表法

   3. 图的遍历
      1. 深度优先遍历DFS是怎么实现的？

         DFS可以递归调用，当然可以用栈进行遍历，不过递归调用深度优先算法比较简单。具体思路就是访问顶点v，再对顶点v相连的未被访问的顶点w1进行访问，再从w1出发访问与w1相连的未被访问的顶点，依次重复以上操作，当不能再向下访问时，就依次退回到最近被访问的顶点。

      2. 广度优先遍历BFS是怎么实现的？

         首先从一个顶点v开始访问并将其入队，将v出队后，把与v相连的未访问的结点依次访问并入队；再将这些在队列中已经访问过的结点出队，依次将每个结点相连的未访问的结点依次访问并入队，重复以上过程就可遍历当前联通图的所有结点。如果还有其他的连通分量没有访问的话，就从未访问的结点再开始广度优先遍历。

   4. 图的应用？
      1. 最小生成树是什么？

         权重之和最小的生成树就是最小生成树。

         * 最小生成树的权值之和是唯一的，但树形是不唯一的。
         * 最小生成树的边数为顶点数加一。

      2. prim算法？克鲁斯卡尔算法？

         这两个算法都是求最小生成树的算法，prim算法是从一个顶点出发找寻与其相连权值最小的顶点，在不形成回路的情况下，将顶点加入其中进而实现最小生成树。克鲁斯卡尔算法就是每次选择一条权值最小的边，将两头的顶点连通，原先已经加入生成树的边就不选，直到实现所有顶点都连通就实现了最小生成树。

      3. 最短路径是什么？

         当图是带权图的话，带权路径长度最小的那条路径称为最短路径。

      4. 迪杰斯特拉算法？floyd算法？

         * 迪杰斯特拉算法主要是不断更新最短路径的算法，利用的就是由源点加中转点去更新达到其余顶点的最小路径。比如说第一轮循环，我假设v1连着v2和v5，那么比较v1到v2的权值和v1到v5的权值，如果v1到v5最小，那么就说明在这一轮循环中我找到了v1到v5的最短路径，此时将v5加入到不再更新权值的集合当中。在第二轮循环中，以v1加v5来更新其余顶点的最小路径，将v1加v5到达其余顶点的权值比原来的权值还要小的进行更新，比原来的权值还要大的不进行更新。在这一轮循环中找到权值之和最小的顶点作为当前v1到达该顶点的最短路径，并将该顶点加入到不再更新权值的集合当中。以此类推，就构成了迪杰斯特拉算法。
         * 迪杰斯特拉不能使用在负权图，可以用在无向和有向图当中。
         * 弗洛伊德算法是求任意顶点的最短路径。一般三个for循环就可以实现弗洛伊德算法。第一层for循环就是中转顶点的编号，第二层和第三层就是对领接矩阵或者领接表的一个全体遍历。

      5. BFS求最短路径问题？

         BFS最短路径算法实际上是单源求无权图的算法。

         BFS求最短路径算法就是对BFS进行小改，用一个数组存储最短路径，还可以用一个数组存储前驱结点，由层序遍历就可以实现对一个顶点对其余顶点的最短路径。

      6. AOV图？AOE图？

         1. 首先明确DAG图是有向无环图
         2. AOV图是用顶点表示活动，用边来表示活动之间的关系。
         3. AOE图是用顶点表示事件，用边表示活动。
         4. 区别：AOV图没有权值，AOE图可以有权值。

      7. 拓扑排序是什么意思？

         1. 从AOV图中选择一个入度为0的顶点开始输出
         2. 从图中删除该顶点和所有以它为顶点的边。
         3. 重复1和2，直到图中不再存在顶点为止。

      8. 关键路径问题？

7. **查找**

   **请熟练手写顺序哨兵算法，折半查找代码**

   1. 顺序查找

      从头扫到脚，或者利用哨兵实现从尾扫到头。

   2. 折半查找

      折半查找只使用于有序的顺序表。首先给定key值与当前mid指针指向的元素进行比较，如果相等就代表找到了；如果key大于mid指向元素的话，那就说明key的值只能在前半部分寻找，也就是将high指针移到mid-1的位置；如果key小于mid指向元素的话， 那就说明key的值只能在后半部分寻找，也就是将low指针移到mid+1的位置。那么如果low大于high指针，代表查找失败。

   3. 分快查找

      1. 在索引表中确定待查记录所在的块，可顺序查找，可折半查找
      2. 在块中进行顺序查找。

   4. 哈希表(散列表)

      1. 定义：散列表是一种根据关键字可直接访问的数据结构，也就是说散列表建立了关键字与存储地址的直接映射关系。

      2. 散列函数的建立方法：

         1. 除留余数法

            取一个不大于表长但接近表长的质数

         2. 直接定址法

            关键字多少，存储地址就是多少

      3. 处理冲突的方法：

         1. 开放定址法

            1. 线性探测法

               就是对关键字经过哈希函数之后的存储地址进行一个增量相加。当发生冲突时，每次向后探测相邻的元素是否为空。线性探测法就是增量都是0依次加一。

               缺点：很容易造成数据的聚集

            2. 平方探测法

               还是对关键字经过哈希函数之后的存储地址进行一个增量相加。但这个增量是以平方呈现。增量d一般是0，1，-1，4，-4。

               平方探测法不容易造成数据的堆积。

            3. 再散列法

               就是多准备几个哈希函数，当第一个哈希函数后，关键字对应的存储地址发生冲突，就用第二个哈希函数进行计数，直到不发生冲突为止。

         2. 拉链法

            发生冲突时，像链表一样，往下增加。也就是把所有的同义词存储在一个线性链表当中。

8. **排序**

   **请熟练手写直接插入，折半，希尔，冒泡，快速，简单选择，堆排序，归并的代码**

   1. 插入排序
      1. 直接插入排序

         直接插入排序是以局部有序逼近全局有序的方式进行排序。每次将一个待排序的数按照大小插入到前面已经有序的子序列当中，直到全部元素插入完成。

      2. 折半插入排序

         折半插入是在直接插入上的一个优化，就将对直接插入排序中对寻址插入位置的方式从顺序查找改为折半查找。

      3. 希尔排序

         希尔排序是将待排序表按照步长依次递减的方式分割成若干个子表，对子表进行直接插入排序。比如说我这里有8个元素，以步长4,2,1进行希尔排序。当以4为步长的时候，分割成4个子表，对每个子表进行直接插入排序；当以2为步长的时候，分割成2个子表，依次进行直接插入排序；当以1为步长的时候，就对原表进行直接插入排序。

         折半插入排序和希尔排序都是针对直接插入排序优化得来的。其中希尔排序是不稳定的排序。
   2. 交换排序
      1. 冒泡排序

         从前往后或者说从后往前依次两两比较相邻的元素，如果为逆序，就交换它们，将最大或者最小的元素送到该序列的最后一个位置。实际上两个for循环就能完成冒泡排序。

      2. 快速排序
   3. 选择排序
      1. 简单选择排序
      2. 堆排序
   4. 归并排序和基排序

## 4.单片机

1. **基本概念**

   1. 什么是微型计算机系统或者问你什么是单片机？

      单片机就是由cpu，存储器，输入输出接口及其他功能部件等组成，它们由地址总线，数据总线，控制总线进行连接。

   2. 单片机最小系统？

      单片机最小系统包含5V电源，晶振，还有复位电路。

   3. 振荡周期，时钟周期，机器周期

      振荡周期是单片机最小的时序单位。时钟周期是振荡周期经过二分频之后提供给cpu的时钟周期，一个时钟周期包含两个振荡周期。机器周期是单片机执行一个基本操作的时间单位，包含六个时钟周期，也就是包含十二个振荡周期。这也就是为什么当我们计算TH0，TL0时候要对晶振周期除以12。

      那么如果说晶振频率为12mhz，振荡周期就是1/12微秒，再乘以12就是机器周期，所以一般来说12mhz的晶振对应的机器周期就是1微秒。

   4. 什么是哈弗结构？

      哈弗结构就是将程序存储器和数据存储器分开，利用地址总线，数据总线，控制总线对存储器进行连接。

   5. 总线结构有哪三种？

      1. 地址总线：地址总线用于传送cpu发出的地址信息，是单向总线。
      2. 数据总线：数据总线用来传送cpu和存储器以及io口的指令代码和数据信息。
      3. 控制总线：控制总线用来传送系统各个部件协调工作的控制信号，时序信号和状态信息等。

   6. 相应寄存器TMOD，TCON,IE,IP,SCON,PCON，PSW的概念描述

      TMOD为定时器工作方式寄存器，分别为T1和T0的工作方式选择位，以T0为例从左到右依次为门控位，定时器计数器选择位，M1和M0组成的工作方式选择位

      TCON为定时器控制寄存器，从左到右依次为TF1,TR1,TF0,TR0,IE1,IT1,IE0,IT0，高四位TF位为溢出标志位，TR位为定时器启动位。低四位中的IT0和IT1为外部中断方式选择位，IE0和IE1为中断标志位，发起中断由硬件置位，进入中断后由硬件清零。

      IE是中断允许寄存器。IE中的EA，EX0,EX1,ET0,ET1,ES为中断开关相应，EA为中断总开关。

      SCON为串行口控制寄存器。从左到右依次为SM0，SM1,SM2,REN,TB8,RB8,TI,RI位，其中SM0，SM1是串行口工作方式选择位，SM2是多机通信选择位，REN是接收允许位，TB8,RB8是方式2和方式3中的第九位有效数据，TI和RI是发送完毕标志位和接收完毕标志位，如果申请中断将由软件清0。

      PCON是电源控制寄存器。在串行通信中主要是对最高位SMOD进行设置

      PSW是程序状态字寄存器。

   7. 简述51单片机128字节分布及其特点

      128字节分为3部分，分别是工作寄存器区，位寻址区和用户RAM区。工作寄存器区为00H到1fH，位寻址区是20H到2FH，用户RAM区是30H到7FH。

      * 工作寄存器区有四组工作寄存器，每组都是R0到R7。对于工作寄存器组的转换，可以用PSW的寄存器RS0和RS1进行选择
      * 位寻址区有16个单元，可以进行位操作，也可以进行字节操作
      * 用户RAM区也叫作通用数据区，一般都是用于堆栈和存放程序运行时的数据和结果。

   8. 80C51的P0到P3口在结构上有什么不同？在使用上有什么特点？

      作为通用IO口来使用时，P0，p1p2p3都是准双向口，都要对其进行写1操作，这个是由硬件复位自动进行。

      P0口作为数据地址总线来使用时，是真正的双向口。P1口只有输入输出功能。P2口也可以作为地址总线的高8位来使用。P3口是双功能口，每个位都对应了相应的引脚功能。

2. **汇编语言**

   1. 请你说出几种寻址方式
      1. 直接寻址
      2. 立即寻址
      3. 间接寻址
      4. 寄存器寻址
      5. 寄存器间接寻址
      6. 相对寻址
      7. 位寻址

3. **定时器计数器**

   1. 请你简述定时器计数器的4种工作方式有何特点？
      * 方式0：方式0是13位加一计数器，以T0举例，当C/T位置0时，对内部机器周期进行计数，这种也叫作定时器。当C/T位置0时，对外部引脚进行计数。方式0中TL0为低五位，TH0为高八位。TL0低五位溢出向TH0进位，TH0溢出时将TF0置位，进而申请定时器中断0。
      * 方式1：方式1的操作方式与方式0基本相同，但方式1是16位计数器，也就是TL0和TH0要同时用到。
      * 方式2：方式2是自动装载初值计数器，为八位计数器，TL0溢出时会产生两个动作：TH0重新赋值给TL0，将TF0置位，可查询或者申请中断。
      * 方式3：方式3只使用T0定时器，将TL0用作8位定时器或者计数器，将TH0只用作8位定时器。TL0工作方式与方式0和方式1完全相同，占用的T0的相关寄存器，TH0工作时占用的是T1的相关寄存器。

4. **中断**

   1. 请你简述中断的过程
      1. 中断源发出请求
      2. 对中断请求进行响应
      3. 执行中断服务程序
      4. 返回主程序

5. **串行口**

   1. 请你简述串行口的工作方式

      四种工作方式由SCON寄存器的SM0和SM1进行配置。

      方式0是同步串行通信，SM0和SM1为00，由RXD端进行接收和发送，由TXD端发送同步时钟脉冲

      方式1是异步串行通信，SM0和SM1为01，RXD端作为接收端，TXD作为发送端。方式1的一帧为1个起始位，八位数据位，1个停止位。波特率是可变的，由PCON的SMOD位和定时器T1进行设置。

      方式2是异步通信，SM0和SM1位

   2. 同步和异步的区别

      * 同步需要发送端和接收端需要保证在一定的时钟频率下工作。一般就是rxd端用来接收和发送数据，txd端发送同步时钟脉冲，这是一种半双工的发送方式。在单片机内就是串行口工作方式0。
      * 异步就是发送端和接收端不需要一定的时钟频率，只是需要保证一定的波特率发送帧数据，一般来说异步通信需要一个起始位，接着需要八位或者九为的数据位，最后需要一个停止位。可以实现全双工的工作方式。其中方式1和方式3的波特率是可变的，由定时器T1和PCON进行设置，方式2的波特率是固定的。
      * 总之，同步通信就像你跟快递员面对面签收快递，而异步通信就像快递员给我发消息，让我去取快递。

   3. 单工，半双工，全双工

      1. 单工：通信时只能有A发送到B
      2. 半双工：通信时A可以发送到B，B也可以发送给A，但不能同时进行
      3. 全双工：A和B可以同时接收和发送。

6. **外围接口技术**

   1. 为什么要消除键盘的机械抖动？

      因为如果不消除机械抖动的话，程序会检测到多个下降沿，cpu可能会对一次按键操作多次处理，从而产生错误。

   2. 怎么用软件消除按键抖动？

      就是在确认按键按下后加上一段延时程序，一般来说前沿抖动范围是5到10ms，那么延时程序一般就是10ms，10ms之后如果还是检测到低电平就判断按键确实已被按下，之后进入按键对应的动作程序。当检测按键释放时，也要加上一个10ms的延时程序，因为按键释放时也会有一个机械抖动。

   3. LED灯的静态显示和LED灯的动态显示

      1. 静态显示：多个数码管显示时，同时点亮显示，每一位数码管恒定显示，不闪烁，但要求的IO口多
      2. 动态显示：多个数码管显示时，循环点亮每个数码管，利用人的视觉错误，只要闪烁得足够快，就能够达到相对静止的效果，优点就是节约IO口

      

问到io口或者不会的问题：

抱歉老师，我本科阶段单片机io口扩展这一块是不教的，所以我就是按我本科阶段所学习的内容进行复习。说到底还是自己准备不太充分，抱歉老师。

## 5.我的项目

1. 你当时是怎么做这个项目的？

   我主要是用到TensorFlow和keras来制作这个项目。主要是以keras为主。

   当时的赛题是用小数据训练出能识别25类美食图片的模型，但比赛方提供了75种美食的图片。比赛的赛题就是暗示我们得微调模型，所以我就是按照微调模型的思路来做这个项目。首先用75类图片的大数据集训练出一个大概的模型，然后将除了最后三层网络的其余网络全部冻结，只保留最后的三层网络，再将25类图片的小数据集用重载的模型再训练一遍。

   在整个训练过程中，我遇到几个问题

   第一，训练很慢，即使是在gpu上运行跑完整个代码也需要十个小时左右。

   我的解决办法就是将resnet50训练image数据集的模型载入到我的代码中，在这个基础上跑就只要五个小时左右。

   第二，严重过拟合问题。我前几次训练后测试集的准确率都是百分之三十四十左右，经过调参处理达到最后的百分之七十四，在所有队伍中排名第一，因此拿到了当时的一等奖。我主要采用的调参方式有：

   1.调整epoch，也就是调整合适的训练周期。

   2.数据增强。其实一个好的数据集，即使算法再一般，最后训练出的结果可能也不会差强人意。一个好的数据集，往往能让训练过程事半功倍。在我这个项目中，数据增强是防止过拟合的最重要的步骤。对数据集进行了一个再扩容，也就是调整keras的ImageDataGenerator函数的参数，我基本上对这个ImageDataGenerator函数所有关键字的参数都进行修改，比如说平移，旋转，加入噪声等等。

   3.选择合适的超参数。比如说第一次训练基础模型时我选择了adam，第二次微调模型时选择了sgd。因为我参考资料的时候发现rmsprop或者adam这种可以自动调整学习率的算法可能会破坏小数据训练时的权值，我对比了一下，我微调模型选用adam的话，测试集准确率为百分之70，选择sgd就为百分之74，还是有点提升的。

2. 你的毕业设计是什么？

   我的毕业设计就是利用树莓派设计一个能人脸识别的系统。

   我之前做过两个关于人脸识别的项目。第一个主要是网络识别。实现逻辑主要是拍照，调用api将照片上传到百度，百度那边返回json数据，将人脸识别的置信度给取出来，判断准确了执行一些动作，比如说开灯，开锁等功能。第二个是本地识别。就是利用opencv来实现一个大概的人脸检测，但这个项目比较简陋，我实际上就是把opencv已经编译好的人脸识别模型导入进去了。

   我做的这两个都有缺点，第一个就是网络api识别的准确度很高，但它实现的是通过拍照上传的方式，还必须得有网。第二个人脸识别项目就是利用opencv制作的识别置信度很低，但能实现实时检测的效果。

   我现在这个毕业设计的主要思路就是利用本地识别的方式实现准确率比较高的人脸识别系统,并且具有人脸录入,实时检测等功能，最后我会采用pyqt对当前项目进行一个封装，在树莓派的显示屏上实现一个完成度很高的人脸识别界面，我希望能通过这次毕业设计克服我之前这两个项目的缺点。

3. 请问你的树莓派的人脸识别系统是怎么做的？

   我关于人脸识别的项目一共做过两个。第一个是利用opencv去导入opencv本来就编译好的人脸识别模型，但因为当时我还没学如何训练人脸数据集，没法对人脸进行标签，所以我选择了放弃。接着我选择了第二个思路，就是利用百度api对人脸进行识别。我将需要进行人脸识别的照片上传到百度那边，由百度解析结果，之后返回一个json数据，在我看来json就相当于一个字典了，将字典中的匹配结果的置信度提取出来，通过if语句判断置信度是否大于百分之80，如果大于的话，就相当于识别成功了，就可以进行if语句里的动作了。当然这个项目识别准确率很高，但必须得有网才行，我的毕业设计还是想完成第一个思路，就是利用本地库的方式达成人脸录入，识别率高等要求，最后我会用pyqt将项目封装起来。

4. 请问你的智能家居系统是怎么做的？

   谢谢老师提问。我的智能家居系统是由语音控制的。

   整个项目的第一步就是搭建语音系统。语音系统就三步：语音转文字，文字转交互结果，交互结果转语音。这实际上实现了一个比较智能但反应很慢的语音聊天机器人的功能。

   那么整个项目的第二步，就是搭建物联网系统。我首先从GitHub上拉取了一个智能家居的项目，按照这个项目给的方案，在云服务器上部署了emq的服务端。这个emq服务端就对家用网络进行监听，基于mqtt协议发送消息。树莓派这边作为发布端发送消息。这样就可以随时随地实现对家居的启用。

   项目运行的操作逻辑就是我说一句话，比如说“开灯”，语音转换文字，从文字中识别到关键字“开灯”，由树莓派这边的发布端向服务端发送消息，服务端再向客户端发送定义好的消息，这样就可以把灯打开了。